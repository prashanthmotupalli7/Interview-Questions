Generics
---------
It is used to deal with type safe objects.
we can avoid class cast exception by using Generics
if we use genrics u need not to perform the type casting explitly
So Java compiler apply strong type checking if we use generics in u r code
and shows error if the code voiltaes the type safety and remove the type casting exception




Ways to create object in Java:
-------------------------------
by using new keyword 
ClassName  className=new ClassName();
Class.forName().newInstance();
Sample obj=(Sample) Class.forName("Sample").newInstance();
Sample obj1 = new Sample();
            Sample obj2 = (Sample) obj1.clone();
 ObjectInputStream ois = new ObjectInputStream(fis);
            Sample obj = (Sample) ois.readObject();
________________________________________________________

 
HashMap,Linked HashMap == one null key, multiple null values
HashTable wont allow null key or null value
TreeMap---won't allow null key but it will allow multiple null values

_______________________________-



TreeMap
----------
provide the implementation of map interface 
stores the data in key value pairs in sorted order 
Use comparator for reverse order
It will provides the key in sorting order
For Internal working it uses  RBT which binary search tree

___________________________

Linked HashMap
-----------------
extennds Hash Map
Maintains insertion order




Thread Life cycle :
New/Born   MyThread t= new MyThread(); 
when we call t.start() thread will enter into Ready/Runnable  state
if thread schedular allocates processor now thread will enter into Running
if run() completes thread will enter to dead to state
If running thread calls yield() then it will enter into ready/runnable
if running thread calls join() then it will enter into waiting state/blocked state
t2.join();
t2.join(1000);
if t2 completes or time expeires or waiting thread get interrupted--it will enter to ready 
or runnable state 

if running thread call sleep()---it will enter into sleeping state 
Thread.sleep(1000);
Thread.sleep(1000,100)---it
If  time expeires or Sleeping thread get interrupted--it will enter to ready 
or runnable state 

If runnig thread calls wait() it will enter into waiting state
obj.wait();
obj.wait(1000);
obj.wait(1000,100);
if waiting thread got notification or if time experies or waiting thread got interrupted.
it will enter into Another waiting state to get lock--if it will got lock it will enter into ready or runnable state
If running thread call t.suspend(); it will enter into suspend state  ---if we call
t.resume() it will enter into ready/runnable
If running thread calls t.stop it will enter into dead state 









Covariant ReturnType: 
-----------------------
before this concept we cannot change the return type of overriden method
but new concept introduced in java called covaraint 
where we can override the return type of overridden method


JVM -- VM provide runtime environment to execute Java byte code
JVM --platform specific

JRE--provides runtime environment to run java applications 
it is implemenation of JVM--along with core class libraries and necess compnts

JDK -- complete DK to developers
JDK contains both JRE and tools 



SingletonDesign Pattern
-----------------------
Singleton -- means we can create one instance for a class
create a static instance 
create a private constructor 
create static method 

Solid design pattern
-------------------
S - Single Responsibilty (whatever class u create --it must have single responsibility)
O- Open Closed(Any  close or any interface u create --should not open for modification)
L - Liskov Substitution principle (In child - parent ---both class must be substitute and interchangable)
I - Interface Seggregation (Interface must have proper methods --not much)
D- Dependency Inversion (we should not deppendency on each of different class)


In Java whenever we  create object of sub class--  it will call constructor of super class and sub class

Every class in java  --is child class of object

Synchronized Block & Synchronized method 
lock held through method scope and block


prevent race condition --Acheive thread safety
block allows --synchronization on specific section of code with in a method
 ______________________

Method Hiding :
Method overriding

_________
HashMap Internal Working :
It is the implementation of Map Interface
It will store the data based on key value pairs
we use put method to store the data
hash map created table array of Nodes<k,v> it size is16
Node is a class that implements Map.Entry<k,v>
Map allways store the data in entry object where key and value stored
And that node is nothing but linked list --contains hash.key,value,node<k,v> next
HashMap will take the key and with the help of key it will generated hash code
from the integer value generated by Hascode --hash map will do hashing --it will return index
where we store the index
 Incase if 2 keys generating same index 1st key will store at particular index
when we are inserting 2nd key ----where collisions happen
here the equals method come to picture if both keys are same --it will update value
or else it will added to next node of the 1st key 
suppose if we have null key it will store at oth index
Suppose if we are storing multiple values in HashMap
if hashing is ending up in same index--for each evry entry we are ended up with collision
we need to travers the linked list and added at end of list 
so for isertion we need to traverse linked list where time complexity id O(n)
for Improvement of above scenario from Java 8 onwords
if particular index reaches with threshold of 8 --- it will converted to balanced tree
with that balance tree-- search,delete and insertion will done effect
when you remove the element and count less than 8 it will convert back linked list
after optimization will lead to time complexity O(logn)
for retriving we do same process
-----------------------------

Concurent HashMap:
It works on the principle of concurency.
whenever we are using multithreaded application we must use concurrent hash map
we can also hashtable aswell that is also thread safe but performance benfit we can get from
concurent hash map is huge.
 
In concurrnet hash map :
for each and every bean(bucket) we will try to store node.
when ever we try to add the data--it will check wether node is null or not
if it is null. at that time it will create node and it will add the data to node
if the node is not null, it will add lock to that particular node
if t1,t2,t3 
bunty-0-t1 
nikhil-1-t2
bunny-0-t3
while multiple threads are trying to insert data and each thread has different hash code  than it will add the data to node
simulataneously
if both thread cantains same hashcode ---one thread will wait for another thread to insert data
at particular time the size of array  is created that many locks acquired for particular operation to be completed of diffrent
threads

//Naming Conventions

Java fallows camelcasee
class name ,interface starts with capital ::ClassName 
variable methods -- starts with small::methodName
constans -- all capital letters:: CONSTANTS


